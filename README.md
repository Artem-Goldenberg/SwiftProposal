# Явный захват `self` во вложенных функциях и методах

## Мотивация

В языке swift используется сборка мусора подсчетом ссылок. Это приводит к проблемам 
с циклическими зависимостями в объектах, нужно следить чтобы их не возникало. Особенно часто
циклические ссылки могут возникнуть при создании замыканий, которые будут храниться в поле
какого-то объекта. Такие замыкания называют `escaping` и если функция или метод хочет принять такое 
замыкание через аргумент и сохранить его в поле какого-то объекта, то она должна пометить это
замыкание через `@escaping` аттрибут. В escaping замыканиях можно использовать поля и методы текущего
класса только, если явно перед ними указывать self, либо объявить `self` в списке захватов замыкания. Это дает пользователю меньше шансов 
случайно создать утечку памяти, сильно захватив `self`. Например 

```swift
class Weather {
    var action: () -> Void
    func onRain(_ action: @escaping () -> Void) {
        self.action = action
    }
}

class Person {
    var localWeather: Weather // can be a cycle
    var isWet: Bool = false
    func walk(under weather: Weather) {
        weather.onRain { 
            self.isWet = true  // got to use self here
        }
        // OR
        weather.onRain { [weak self] in // weak reference here
            self?.isWet = true  // no cycle guarantee
        }
    }
}
```

Теперь если передать одну и ту же погоду:
```swift
let weather = Weather()
let person = Person(weather)
person.walk(under: weather)
```
То в первом варианте вызова `onRain` получится сильный цикл и утечка памяти, но со вторым 
вариантом это можно избежать. Явный захват self здесь помогает задуматься и определить какой конкретно захват мы хотим использовать. 

Но в Swift, помимо явного создания замыкания можно делать вложенные функции. В функциях,
вложенных в метод, можно также использовать методы и поля изначального класса. То есть эти
функции захватывают `self` при этом, в отличии от замыканий, они позволяют делать это неявно.
Такое поведение абсолютно неочевидно для новичков и даже более опытных программистов, привыкших,
что o `weak self` нужно задумываться только тогда, когда компилятор явно просит захватить self.  
Понятно, что это может привести к проблемам с утечками памяти, которые при этом будет 
гораздо сложнее отловить, чем в случае с замыканиями. Поэтому мне кажется, что эта маленькая
деталь потенциально обесценивает весь механизм явного захвата self у замыканий.  

То есть метод `walk` из примера можно написать вот так:

```swift
func walk(under weather: Weather) {
    func action() {
        isWet = true  // don't have to use self
    }
    weather.onRain(action)
}
```

Также такие методы можно возвращать, а возвращенные функции всегда считаются `escaping`:
```swift
func walk(under weather: Weather) -> () -> Void {
    func action() {
        isWet = true  // don't have to use self
    }
    return action
}
```
Помимо вложенных функций можно делать тоже самое с обычными методами, они также никогда не требуют явного упоминания `self`, например:
```swift
class Person {
    var localWeather: Weather // can be a cycle
    var isWet: Bool = false
    func soak() {
        isWet = true
    }
    func walk() {
        localWhether.onRain(soak) // no errors/warnings, but cycle is created
    }
}
```

## Предлагаемое решение

Для лучшего контроля над циклами в программе, я предлагаю добавить явное или неявное
отслеживание каждого метода и вложенной функции на то, являются ли они escaping или нет,
наподобие того как это делается для замыканий.

То есть теперь для каждой вложенной функции и метода будет явно отслеживаться, являются ли они
`esсaping` или нет, и если являются, то от программиста будут требоваться дополнительные 
действия при попытке использовать в таком методе или функции поля из `self`.
Например такой код больше не будет компилироваться. 
```swift
func walk(under weather: Weather) {
    func action() {
        isWet = true // Reference to property 'isWet' in an escaping context requires explicit use of 'self' to make capture semantics explicit
    }
    weather.onRain(action)
}
```

В качестве дополнительных действий у пользователя может быть выбор как и в случае
с замыканиями, где мы можем либо явно писать `self.a` чтобы сослаться на поле `a`, либо
использовать `self` в списке захватов (`[self]`, `[weak self]`, `[unowned self]`).  
В именованных функциях в Swift будет странно видеть список захвата, к тому же в этом списке
может захватываться лишь одна переменная - `self`. Поэтому вместо создания списка
предлагается разрешить применять ключевые слова `weak` и `unowned` к самой декларации функции.  
Методы и вложенные функции, объявленные с этими ключевыми словами будут захватывать `self` как
слабую или непринадлежащую ссылку соответственно. В методах, которые будут хотеть захватить `self` сильно, придется приписывать `self` к каждому обращению к полю. Это нужно
будет делать, только если функция является `escaping`, сильно захватывать `self` в таких случаях, это редкость и ситуация, на которую стоит обратить большое внимание, поэтому
явное написание `self` здесь мне не кажется слишком обременительным.  

Например можно будет писать так:
```swift
weak func perpare() { // capture of the weak self here
    self?.localWeather.onRain(setWet);
}
func walk(under weather: Weather) {
    unowned func action() {
        isWet = true // don't need self, because we are unowned
    }
    weather.onRain(action)
}
```
В обоих этих функциях сильного цикла не происходит.


## Альтернативный синтаксис

Есть альтернативный вариант: вместо неявного отслеживания, какие функции `escaping`, а какие нет, можно явно заставить пользователя помечать любый методы и вложенные функции, которые
потенциально могут быть сохранены в другом месте. Помечать можно с помощью нового 
"мягкого" ключевого слова `escaping` или просто расширить применение аттрибута `@escaping`,
который и так уже используется для замыканий, на методы и вложенные функции, в общем на все,
что захватывает неявный контекст. Далее будем использовать аттрибут `@escaping` потому что он
уже есть и не требует добавления нового ключевого слова.

То есть:

Это больше надо писать кода программисту, но зато опять же меньше шансов допустить ошибку и создать цикл.

```swift
class Person {
    var localWeather: Weather // can be a cycle
    var isWet: Bool = false
    @escaping // escapes in the `walk` method
    weak func setWet() {
        self?.isWet = true
    }
    @escaping // marked escaping just in case, but still captures self strongly
    func other() {
        self.localWeather.onRain(setWet);
    }
    func walk(under weather: Weather) {
        weather.onRain(setWet)
    }
}
```

## Совместимость изменений

Эти изменения несовместимы с текущей версией Swift. То есть, если их внедрить и заставить
теперь везде контролировать захват `self`, то много уже написанного кода может сломаться. Поэтом
в текущей версии можно ввести аттрибут для объявления класса `@strictMemory` (наподобие многих других таких атрибутов в Swift: `@main` `@available` `@discardableResult` ...).  В новой версии
можно сделать это поведение `@strictMemory` по умолчанию. 
Например
```swift
@strictMemory
class Criminal: Person { 

}
```
Теперь все захваты экземпляров класса `Criminal` должны быть явными.


## Детали реализации

При введении модификатора `@strictMemory` нужно иметь ввиду наследование. Если базовый класс
не объявлен со `@strictMemory`, а его потомок объявлен, то нужно делать проход по переопределенным
методам класса потомка и смотреть, не являются ли они `escaping` в базовом классе. Благо
статическая природа Swift это позволяет.

Например, здесь нужно применять isWet, вместе с `self`

```swift
class Person { 
    var isWet: Bool = false
    func setWet() { 
        isWet = true  // self capture but `strict` not required
    }
    func walk(under weather: Weather) {
        weather.onRain(setWet) // setWet is escaping
    }
}
@strictMemory
class Criminal: Person { 
    // must be marked @escaping if we are using explicit marking
    override func setWet() {
        print("\(Self)s are escaping !!!")
        isWet = true // Reference to property 'isWet' in an escaping context requires explicit use of 'self' to make capture semantics explicit
    }
}
```

Также стоит обратить внимание на переопределение `weak` и `unowned` методов. Для простоты
можно ограничиться правилом, что все ключевые слова должны сохранятся 1 в 1 в переопределенном
методе. То есть `weak` метод может быть переопределен только другим `weak` методом например.
